package docs

// This file was generated from [builtins/core/typemgmt/math_doc.yaml](https://github.com/lmorg/murex/blob/master/builtins/core/typemgmt/math_doc.yaml).

func init() {

	Definition["="] = "# `=` (arithmetic evaluation)\n\n> Evaluate a mathematical function (deprecated)\n\n## Description\n\n`=` evaluates a mathematical function and returns it's output\n\n**This is a deprecated feature. Please refer to [`expr`](expr.md) instead.**\n\n## Usage\n\n```\n<stdin> -> = evaluation -> <stdout>\n\n= evaluation -> <stdout>\n```\n\n## Examples\n\nAs a method:\n\n```\n» let age=18\n» $age -> = < 21\ntrue\n\n» $age -> = < 21 -> if { out \"Under 21\" } else { out \"Over 21\" }\nUnder 21\n```\n\nAs a function:\n\n```\n» let age=18\n» = age < 21\ntrue\n\n» = age < 21 -> if { out \"Under 21\" } else { out \"Over 21\" }\nUnder 21\n```\n\nInlining as a function:\n\n```\n» let age=18\n» if { = age < 21 } then { out \"Under 21\" } else { out \"Over 21\" }\nUnder 21\n```\n\n## Detail\n\n### Variables\n\nThere are two ways you can use variables with the math functions. Either by\nstring interpolation like you would normally with any other function, or\ndirectly by name.\n\nString interpolation:\n\n```\n» set abc=123\n» = $abc==123\ntrue\n```\n\nDirectly by name:\n\n```\n» set abc=123\n» = abc==123\nfalse\n```\n\nTo understand the difference between the two, you must first understand how\nstring interpolation works; which is where the parser tokenised the parameters\nlike so\n\n```\ncommand line: = $abc==123\ntoken 1: command (name: \"=\")\ntoken 2: parameter 1, string (content: \"\")\ntoken 3: parameter 1, variable (name: \"abc\")\ntoken 4: parameter 1, string (content: \"==123\")\n```\n\nThen when the command line gets executed, the parameters are compiled on demand\nsimilarly to this crude pseudo-code\n\n```\ncommand: \"=\"\nparameters 1: concatenate(\"\", GetValue(abc), \"==123\")\noutput: \"=\" \"123==123\"\n```\n\nThus the actual command getting run is literally `123==123` due to the variable\nbeing replace **before** the command executes.\n\nWhereas when you call the variable by name it's up to `=` or `let` to do the\nvariable substitution.\n\n```\ncommand line: = abc==123\ntoken 1: command (name: \"=\")\ntoken 2: parameter 1, string (content: \"abc==123\")\n```\n\n```\ncommand: \"=\"\nparameters 1: concatenate(\"abc==123\")\noutput: \"=\" \"abc==123\"\n```\n\nThe main advantage (or disadvantage, depending on your perspective) of using\nvariables this way is that their data-type is preserved.\n\n```\n» set str abc=123\n» = abc==123\nfalse\n\n» set int abc=123\n» = abc==123\ntrue\n```\n\nUnfortunately is one of the biggest areas in Murex where you'd need to be\ncareful. The simple addition or omission of the dollar prefix, `$`, can change\nthe behavior of `=` and `let`.\n\n### Strings\n\nBecause the usual Murex tools for encapsulating a string (`\"`, `'` and `()`)\nare interpreted by the shell language parser, it means we need a new token for\nhandling strings inside `=` and `let`. This is where backtick comes to our\nrescue.\n\n```\n» set str abc=123\n» = abc==`123`\ntrue\n```\n\nPlease be mindful that if you use string interpolation then you will need to\ninstruct `=` and `let` that your field is a string\n\n```\n» set str abc=123\n» = `$abc`==`123`\ntrue\n```\n\n### Best practice recommendation\n\nAs you can see from the sections above, string interpolation offers us some\nconveniences when comparing variables of differing data-types, such as a `str`\ntype with a number (eg `num` or `int`). However it makes for less readable code\nwhen just comparing strings. Thus the recommendation is to avoid using string\ninterpolation except only where it really makes sense (ie use it sparingly).\n\n### Non-boolean logic\n\nThus far the examples given have been focused on comparisons however `=` and\n`let` supports all the usual arithmetic operators:\n\n```\n» = 10+10\n20\n\n» = 10/10\n1\n\n» = (4 * (3 + 2))\n20\n\n» = `foo`+`bar`\nfoobar\n```\n\n### Read more\n\nMurex uses the [govaluate package](https://github.com/Knetic/govaluate). More information can be found in it's manual.\n\n## Synonyms\n\n* `=`\n\n\n## See Also\n\n* [Reserved Variables](../user-guide/reserved-vars.md):\n  Special variables reserved by Murex\n* [Variable and Config Scoping](../user-guide/scoping.md):\n  How scoping works within Murex\n* [`(` (brace quote)](../commands/brace-quote.md):\n  Write a string to the STDOUT without new line\n* [`[[` (element)](../commands/element.md):\n  Outputs an element from a nested structure\n* [`export`](../commands/export.md):\n  Define an environmental variable and set it's value\n* [`expr`](../commands/expr.md):\n  Expressions: mathematical, string comparisons, logical operators\n* [`global`](../commands/global.md):\n  Define a global variable and set it's value\n* [`global`](../commands/global.md):\n  Define a global variable and set it's value\n* [`if`](../commands/if.md):\n  Conditional statement to execute different blocks of code depending on the result of the condition\n* [`let`](../commands/let.md):\n  Evaluate a mathematical function and assign to variable (deprecated)\n* [`set`](../commands/set.md):\n  Define a local variable and set it's value\n* [index](../commands/item-index.md):\n  Outputs an element from an array, map or table\n\n<hr/>\n\nThis document was generated from [builtins/core/typemgmt/math_doc.yaml](https://github.com/lmorg/murex/blob/master/builtins/core/typemgmt/math_doc.yaml)."

}
